{% extends 'base.html' %}
{% load static %}

{% block title %}Laundry Data{% endblock %}

{% block content %}
<div class="container">
    <div class="row mb-2">
        <div class="col-md-6 fw-bold text-black-50">
            <h5>SETTINGS</h5>
        </div>
        <div class="col-md-6 text-end">
            <nav aria-label="breadcrumb" class="d-inline-block">
                <ol class="breadcrumb">
                    <li class="breadcrumb-item"><a href="{% url 'home' %}">Home</a></li>
                    <li class="breadcrumb-item active" aria-current="page">Settings</li>
                </ol>
            </nav>
        </div>
    </div>
    <h1>WiFi Schedule Configuration</h1>
    
    <div class="panel">
        <div class="panel-header">Schedule Configuration</div>
        <div class="panel-bodyv2">
            <!-- Primary WiFi -->
            <div class="form-group primary-wifi-container">
                <label for="primary-wifi">Primary WiFi:</label>
                <select id="primary-wifi" class="form-control">
                    <option value="" disabled selected hidden>Select Primary WiFi</option>
                    <!-- Options will be populated dynamically -->
                </select>
            </div>
            
            <!-- Secondary WiFi -->
            <div class="form-group secondary-wifi-container">
                <label for="secondary-wifi">Secondary WiFi:</label>
                <select id="secondary-wifi" class="form-control">
                    <option value="" disabled selected hidden>Select Secondary WiFi</option>
                    <!-- Options will be populated dynamically -->
                </select>
            </div>
            
            <!-- Switch Time -->
            <div class="form-group switch-time-container">
                <label for="switch-time">Switch Time:</label>
                <input type="time" id="switch-time" class="form-control time-input" value="13:00">
                <small id="switch-time-help" class="form-text text-muted"></small>
            </div>
            
            <!-- Revert Time -->
            <div class="form-group revert-time-container">
                <label for="revert-time">Revert Time:</label>
                <input type="time" id="revert-time" class="form-control time-input" value="13:02">
                <small id="revert-time-help" class="form-text text-muted"></small>
            </div>
            
            <!-- Start Button and Switching Duration -->
            <div class="schedule-controls">
                <button class="btn start-btn" id="start-schedule-btn">Start Schedule</button>
                <div id="switching-duration" class="switching-duration"></div>
            </div>
            
            <!-- Schedule Status Indicator -->
            <div class="schedule-status" id="schedule-status">
                <span class="status-indicator"></span>
                <span class="status-text">Schedule is currently inactive</span>
            </div>
        </div>
    </div>
    
    <div class="panel">
        <div class="panel-header">Connection Status</div>
        <div class="panel-body">
            <div class="status">
                <strong>Connected to:</strong> 
                {% if current_ssid %}{{ current_ssid }}{% else %}Not connected{% endif %}
            </div>
        </div>
    </div>
    
    <div class="panel">
        <div class="panel-header">Activity Log</div>
        <div class="panel-bodyv2">
            <div class="log">
                <table class="log-table">
                    <thead>
                        <tr>
                            <th>Timestamp</th>
                            <th>Message</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody>
                        {% for log in logs %}
                        <tr>
                            <td>{{ log.timestamp }}</td>
                            <td>{{ log.message }}</td>
                            <td>
                                {% if log.is_success %}
                                    <span class="badge badge-success">Success</span>
                                {% else %}
                                    <span class="badge badge-danger">Error</span>
                                {% endif %}
                            </td>
                        </tr>
                        {% empty %}
                        <tr>
                            <td colspan="3" style="text-align: center;">System initialized... Ready for configuration.</td>
                        </tr>
                        {% endfor %}
                    </tbody>
                </table>
            </div>
        </div>
    </div>
</div>

<style>
    /* Panel styling remains the same */
    .panel {
        margin-bottom: 20px;
        border: 1px solid #ddd;
        border-radius: 5px;
        overflow: hidden;
    }
    .panel-header {
        background-color: #f8f9fa;
        padding: 12px 15px;
        border-bottom: 1px solid #ddd;
        font-weight: 600;
    }
    .panel-body {
        padding: 15px;
        position: relative; /* Added for absolute positioning context */
        height: 75px; /* Set a fixed height for the panel body */
    }

    .panel-bodyv2 {
        padding: 15px;
        position: relative; /* Added for absolute positioning context */
        height: 230px; /* Set a fixed height for the panel body */
    }
    
    /* Manual positioning for form elements */
    .primary-wifi-container {
        position: absolute;
        top: 20px;
        left: 40px;
        width: 420px;
    }
    
    .secondary-wifi-container {
        position: absolute;
        top: 70px;
        left: 40px;
        width: 420px;
    }
    
    .switch-time-container {
        position: absolute;
        top: 20px;
        left: 500px;
        width: 250px;
    }
    
    .revert-time-container {
        position: absolute;
        top: 70px;
        left: 500px;
        width: 250px;
    }
    
    .start-btn {
        position: absolute;
        left: 40px;
        top: 130px;
        width: 300px;
        height: 50px;
    }
    
    .switching-duration {
        position: absolute;
        top: 130px;
        left: 430px;
        min-width: 200px;
        height: 50px;
        display: flex;
        align-items: center;
        font-size: 14px;
        color: #28a745;
        font-weight: 500;
    }
    
    .form-group {
        display: flex;
        margin-bottom: 15px;
        align-items: center;
    }
    
    .form-group label {
        width: 150px;
        font-weight: 500;
        margin-right: 10px;
    }
    
    .form-control {
        padding: 8px 12px;
        border: 1px solid #ddd;
        border-radius: 4px;
        width: 100%;
    }
    
    .time-input {
        width: 120px;
    }
    
    .btn {
        padding: 2px 2px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-weight: 400;
        width: 350px;
    }
    
    .btn:hover {
        background-color: #0069d9;
    }
    
    /* Updated styles for status and log */
    .status {
        padding: 10px;
        background-color: #f8f9fa;
        border-radius: 4px;
        font-family: monospace;
    }
    
    .log {
        height: 200px;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 10px;
        font-family: monospace;
        background-color: #f8f9fa;
        overflow-y: auto;
    }

    /* Enhanced styles for the activity log table */
    .log-table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        box-shadow: 0 2px 3px rgba(0, 0, 0, 0.1);
        border-radius: 5px;
        overflow: hidden;
    }
    
    .log-table th, .log-table td {
        padding: 12px 15px;
        text-align: left;
    }
    
    .log-table th {
        background-color: #3a7bd5;
        color: white;
        font-weight: 500;
        text-transform: uppercase;
        font-size: 13px;
        letter-spacing: 0.5px;
        border: none;
    }
    
    .log-table tr {
        border-bottom: 1px solid #eee;
        transition: background-color 0.3s ease;
    }
    
    .log-table tr:nth-child(even) {
        background-color: #f9f9f9;
    }
    
    .log-table tr:hover {
        background-color: #f0f7ff;
    }

    .log-table tr:last-child td {
        border-bottom: none;
    }
    
    .badge {
        padding: 5px 10px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 500;
        display: inline-block;
        text-align: center;
        letter-spacing: 0.5px;
        min-width: 80px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12);
    }
    
    .badge-success {
        background-color: #00c853;
    }
    
    .badge-danger {
        background-color: #ff3d00;
    }

    .schedule-status {
        position: absolute;
        top: 180px;
        left: 40px;
        display: flex;
        align-items: center;
        font-size: 14px;
        font-weight: 500;
    }
    
    .status-indicator {
        display: inline-block;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background-color: #ccc; /* Default gray */
        margin-right: 8px;
    }
    
    .status-indicator.active {
        background-color: #28a745; /* Green when active */
        box-shadow: 0 0 8px #28a745;
        animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
        0% { opacity: 1; }
        50% { opacity: 0.6; }
        100% { opacity: 1; }
    }
    
    .active-schedule {
        background-color: #dc3545; /* Red for stop button */
    }
    
    .active-schedule:hover {
        background-color: #c82333; /* Darker red on hover */
    }
</style>



<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Declare all DOM elements once at the beginning
        const primaryDropdown = document.getElementById('primary-wifi');
        const secondaryDropdown = document.getElementById('secondary-wifi');
        const switchTimeInput = document.getElementById('switch-time');
        const revertTimeInput = document.getElementById('revert-time');
        const switchingDuration = document.getElementById('switching-duration');
        const startButton = document.getElementById('start-schedule-btn');
        const statusDiv = document.querySelector('.status');
        const scheduleStatusIndicator = document.querySelector('.status-indicator');
        const scheduleStatusText = document.querySelector('.status-text');
        
        // Schedule state variables
        let scheduleRunning = false;
        let scheduleTimer = null;
        let lastAction = null;

        // Function to update UI based on schedule state
        function updateScheduleUI(isRunning, message = null) {
            scheduleRunning = isRunning;
            
            // Update button text and style
            startButton.textContent = isRunning ? 'Stop Schedule' : 'Start Schedule';
            
            if (isRunning) {
                startButton.classList.add('active-schedule');
                scheduleStatusIndicator.classList.add('active');
                scheduleStatusText.textContent = message || 'Schedule is currently active';
                
                // Disable configuration fields
                primaryDropdown.disabled = true;
                secondaryDropdown.disabled = true;
                switchTimeInput.disabled = true;
                revertTimeInput.disabled = true;
                
            } else {
                startButton.classList.remove('active-schedule');
                scheduleStatusIndicator.classList.remove('active');
                scheduleStatusText.textContent = 'Schedule is currently inactive';
                
                // Enable configuration fields
                primaryDropdown.disabled = false;
                secondaryDropdown.disabled = false;
                switchTimeInput.disabled = false;
                revertTimeInput.disabled = false;
            }
            
            // Save to localStorage for UI state persistence
            localStorage.setItem('laundry_app_schedule_running', isRunning.toString());
        }

        // Load saved settings from localStorage
        function loadSavedSettings() {
            // Load switch time
            const savedSwitchTime = localStorage.getItem('laundry_app_switch_time');
            if (savedSwitchTime) {
                switchTimeInput.value = savedSwitchTime;
            }
            
            // Load revert time
            const savedRevertTime = localStorage.getItem('laundry_app_revert_time');
            if (savedRevertTime) {
                revertTimeInput.value = savedRevertTime;
            }
            
            // Load schedule running status
            const savedScheduleRunning = localStorage.getItem('laundry_app_schedule_running') === 'true';
            scheduleRunning = savedScheduleRunning;
            
            // When networks are loaded, we'll restore primary and secondary selections
            const savedPrimaryNetwork = localStorage.getItem('laundry_app_primary_network');
            const savedSecondaryNetwork = localStorage.getItem('laundry_app_secondary_network');
            
            // Return saved network selections for use when networks are loaded
            return {
                primaryNetwork: savedPrimaryNetwork,
                secondaryNetwork: savedSecondaryNetwork
            };
        }
        
        // Save settings to localStorage whenever they change
        function saveSettings() {
            // Save times
            localStorage.setItem('laundry_app_switch_time', switchTimeInput.value);
            localStorage.setItem('laundry_app_revert_time', revertTimeInput.value);
            
            // Save networks
            if (primaryDropdown.value) {
                localStorage.setItem('laundry_app_primary_network', primaryDropdown.value);
            }
            if (secondaryDropdown.value) {
                localStorage.setItem('laundry_app_secondary_network', secondaryDropdown.value);
            }
            
            // Save schedule state
            localStorage.setItem('laundry_app_schedule_running', scheduleRunning.toString());
        }

        //New
    //    // Function to fetch available saved networks from the computer
    //     async function fetchSavedNetworks() {
    //         try {
    //             if (statusDiv) {
    //                 statusDiv.innerHTML = '<strong>Connection Status:</strong> <span style="color: #007bff;">Fetching network information...</span>';
    //             }

    //             const currentNetwork = await getCurrentNetwork();
    //             const response = await fetch('/api/available-saved-networks/');

    //             if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);

    //             const data = await response.json();
    //             console.log("Network API response:", data);

    //             if (data.error) throw new Error(data.error);

    //             let networks = Array.isArray(data) ? data : [];
    //             if (currentNetwork && !networks.some(n => n.ssid === currentNetwork.ssid)) {
    //                 networks.unshift(currentNetwork);
    //             }

    //             networks = networks.filter(n => n.isSaved && (n.isAvailable || n.isConnected));
    //             updateConnectionStatus(networks, currentNetwork || networks.find(n => n.isConnected));
    //             return networks;

    //         } catch (error) {
    //             console.error('Error fetching saved networks:', error);

    //             try {
    //                 const fallbackNetwork = await getCurrentNetworkFallback();
    //                 if (fallbackNetwork) {
    //                     if (statusDiv) {
    //                         statusDiv.innerHTML = `<strong>Connected to:</strong> ${fallbackNetwork.ssid} (limited detection)`;
    //                     }
    //                     return [fallbackNetwork];
    //                 }
    //             } catch (fallbackError) {
    //                 console.error('Fallback method failed:', fallbackError);
    //             }

    //             if (statusDiv) {
    //                 statusDiv.innerHTML = `<strong>Connection Status:</strong> <span style="color: #ff3d00;">Error: ${error.message}</span>`;
    //             }

    //             return [];
    //         }
    //     }

    //     // Remaining helper functions (unchanged)
    //     async function getCurrentNetwork() { /* ...same as before... */ }
    //     async function getCurrentNetworkFallback() { /* ...same as before... */ }
    //     function attemptClientSideWifiDetection() { /* ...same as before... */ }
    //     function updateConnectionStatus(networks, currentNetwork) { /* ...same as before... */ }

    //     // Function to populate dropdowns
    //     async function populateWifiDropdowns() {
    //         primaryDropdown.innerHTML = '<option value="" disabled selected>Loading networks...</option>';
    //         secondaryDropdown.innerHTML = '<option value="" disabled selected>Loading networks...</option>';

    //         const savedSettings = loadSavedSettings();
    //         const networks = await fetchSavedNetworks();

    //         primaryDropdown.innerHTML = '<option value="" disabled hidden>Select Primary WiFi</option>';
    //         secondaryDropdown.innerHTML = '<option value="" disabled hidden>Select Secondary WiFi</option>';

    //         if (!networks || networks.length === 0) {
    //             console.warn('No networks found');
    //             primaryDropdown.innerHTML = '<option value="" disabled selected>No networks detected</option>';
    //             secondaryDropdown.innerHTML = '<option value="" disabled selected>No networks detected</option>';

    //             if (statusDiv) {
    //                 statusDiv.innerHTML = '<strong>Connection Status:</strong> <span style="color: #ff7700;">No WiFi networks were detected. Please ensure WiFi is enabled.</span>';
    //             }

    //             return;
    //         }

    //         const currentNetwork = networks.find(network => network.isConnected || network.isCurrent);
    //         networks.sort((a, b) => {
    //             if (a.isConnected || a.isCurrent) return -1;
    //             if (b.isConnected || b.isCurrent) return 1;
    //             return a.ssid.localeCompare(b.ssid);
    //         });

    //         let primaryToSelect = savedSettings.primaryNetwork || (currentNetwork && currentNetwork.ssid);

    //         networks.forEach(network => {
    //             const option = document.createElement('option');
    //             option.value = network.ssid;
    //             option.textContent = network.ssid;
    //             if (network.ssid === primaryToSelect) option.selected = true;
    //             primaryDropdown.appendChild(option);
    //         });

    //         primaryDropdown.dataset.networksList = JSON.stringify(networks);
    //         updateSecondaryDropdownFromNetworks(networks, savedSettings.secondaryNetwork);

    //         primaryDropdown.removeEventListener('change', handlePrimaryChange);
    //         primaryDropdown.addEventListener('change', handlePrimaryChange);

    //         updateScheduleInfo();
    //     }

    //     // ✅ Add this once to ensure Retry button works
    //     document.addEventListener('DOMContentLoaded', () => {
    //         const retryBtn = document.getElementById('retryScanBtn');
    //         if (retryBtn) {
    //             retryBtn.addEventListener('click', async () => {
    //                 console.log('Retry button clicked: rescan starting...');
    //                 await populateWifiDropdowns();
    //             });
    //         }

    //         // Initial population
    //         populateWifiDropdowns();
    //     });



        // Function to fetch available saved networks from the computer
        async function fetchSavedNetworks() {
            try {
                // Loading state in status div
                if (statusDiv) {
                    statusDiv.innerHTML = '<strong>Connection Status:</strong> <span style="color: #007bff;">Fetching network information...</span>';
                }
                
                // Fetch actual saved networks from our API endpoint
                const response = await fetch('/api/available-saved-networks/');
                
                // Check if the fetch was successful
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Log the raw response for debugging
                console.log("Network API response:", data);
                
                // Check if we got an error response
                if (data.error) {
                    throw new Error(data.error);
                }
                
                // Make sure we have an array of networks and filter out any possible dummy networks
                let networks = Array.isArray(data) ? data : [];
                
                // Only use saved and available networks
                networks = networks.filter(n => n.isSaved && n.isAvailable);
                
                // Update the connection status in the UI
                if (statusDiv) {
                    const currentNetwork = networks.find(network => network.isConnected);
                    if (currentNetwork) {
                        statusDiv.innerHTML = `<strong>Connected to:</strong> ${currentNetwork.ssid}`;
                    } else if (networks.length > 0) {
                        statusDiv.innerHTML = '<strong>Connected to:</strong> Not connected to any known network';
                    } else {
                        statusDiv.innerHTML = '<strong>Connection Status:</strong> No WiFi networks detected';
                    }
                }
                
                return networks;
            } catch (error) {
                console.error('Error fetching saved networks:', error);
                
                // Display error in status
                if (statusDiv) {
                    statusDiv.innerHTML = `<strong>Connection Status:</strong> <span style="color: #ff3d00;">Error: ${error.message}</span>`;
                }
                
                // Return empty array when there's an error instead of fallback networks
                return [];
            }
        }

        // Function to populate dropdowns
        async function populateWifiDropdowns() {
            // Show loading indicator
            primaryDropdown.innerHTML = '<option value="" disabled selected>Loading networks...</option>';
            secondaryDropdown.innerHTML = '<option value="" disabled selected>Loading networks...</option>';
            
            // Load saved settings
            const savedSettings = loadSavedSettings();
            
            // Fetch actual networks from the computer
            const networks = await fetchSavedNetworks();
            
            // Clear loading message
            primaryDropdown.innerHTML = '<option value="" disabled hidden>Select Primary WiFi</option>';
            secondaryDropdown.innerHTML = '<option value="" disabled hidden>Select Secondary WiFi</option>';
            
            if (!networks || networks.length === 0) {
                console.warn('No networks found');
                primaryDropdown.innerHTML = '<option value="" disabled selected>No networks detected</option>';
                secondaryDropdown.innerHTML = '<option value="" disabled selected>No networks detected</option>';
                
                // Show error message in status
                if (statusDiv) {
                    statusDiv.innerHTML = '<strong>Connection Status:</strong> <span style="color: #ff7700;">No WiFi networks were detected. Please ensure WiFi is enabled.</span>';
                }
                
                return;
            }
            
            // Get current network if available
            const currentNetwork = networks.find(network => network.isConnected);
            
            // Sort networks to put the connected network first
            networks.sort((a, b) => {
                if (a.isConnected) return -1;
                if (b.isConnected) return 1;
                return a.ssid.localeCompare(b.ssid);
            });
            
            // Track which network to select
            let primaryToSelect = null;
            
            // First, try to use the saved primary network if it exists
            if (currentNetwork) {
                primaryToSelect = currentNetwork.ssid;
            } else if (savedSettings.primaryNetwork) {
                primaryToSelect = savedSettings.primaryNetwork;
            }
            
            // Populate primary dropdown
            networks.forEach(network => {
                const option = document.createElement('option');
                option.value = network.ssid;
                option.textContent = network.ssid;
                
                // Select if this matches our target network
                if (network.ssid === primaryToSelect) {
                    option.selected = true;
                }
                
                primaryDropdown.appendChild(option);
            });
            
            // Store original networks list for later use
            primaryDropdown.dataset.networksList = JSON.stringify(networks);
            
            // Update secondary dropdown based on primary selection
            updateSecondaryDropdownFromNetworks(networks, savedSettings.secondaryNetwork);
            
            // Remove any existing event listener first to prevent duplicates
            primaryDropdown.removeEventListener('change', handlePrimaryChange);
            
            // Add event listener to update secondary dropdown when primary selection changes
            primaryDropdown.addEventListener('change', handlePrimaryChange);
            
            // Update the schedule info display
            updateScheduleInfo();
        }
        
        // Helper function to populate both dropdowns
        function populateNetworkDropdowns(networks, savedSettings) {
            // Get current network if available
            const currentNetwork = networks.find(network => network.isConnected);
            
            // Sort networks to put the connected network first
            networks.sort((a, b) => {
                if (a.isConnected) return -1;
                if (b.isConnected) return 1;
                return a.ssid.localeCompare(b.ssid);
            });
            
            // Track which network to select
            let primaryToSelect = null;
            
            // First, try to use the saved primary network if it exists
            if (savedSettings.primaryNetwork) {
                primaryToSelect = savedSettings.primaryNetwork;
            } 
            // Otherwise, use the currently connected network
            else if (currentNetwork) {
                primaryToSelect = currentNetwork.ssid;
            }
            
            // Populate primary dropdown
            networks.forEach(network => {
                const option = document.createElement('option');
                option.value = network.ssid;
                option.textContent = network.ssid;
                
                // Select if this matches our target network
                if (network.ssid === primaryToSelect) {
                    option.selected = true;
                }
                
                primaryDropdown.appendChild(option);
            });
            
            // Store original networks list for later use
            primaryDropdown.dataset.networksList = JSON.stringify(networks);
            
            // Initially populate secondary dropdown (excluding the currently selected primary)
            updateSecondaryDropdownFromNetworks(networks, savedSettings.secondaryNetwork);
            
            // Remove any existing event listener first to prevent duplicates
            primaryDropdown.removeEventListener('change', handlePrimaryChange);
            
            // Add event listener to update secondary dropdown when primary selection changes
            primaryDropdown.addEventListener('change', handlePrimaryChange);
            
            // Update the schedule info display
            updateScheduleInfo();
        }

        // Separate handler function for primary dropdown changes
        function handlePrimaryChange() {
            // Get original networks list
            const networksListJson = primaryDropdown.dataset.networksList;
            if (networksListJson) {
                const networksList = JSON.parse(networksListJson);
                updateSecondaryDropdownFromNetworks(networksList);
            } else {
                // Fallback if data attribute is not available
                updateSecondaryDropdownFromOptions();
            }
            saveSettings(); // Save when selection changes
        }
        
        // Updated function that uses the original networks list
        function updateSecondaryDropdownFromNetworks(networksList, selectedSecondaryNetwork = null) {
            const selectedPrimary = primaryDropdown.value;
            
            // Clear existing options except the first one
            secondaryDropdown.innerHTML = '<option value="" disabled selected hidden>Select Secondary WiFi</option>';
            
            // Get networks excluding the selected primary
            const availableSecondaryNetworks = networksList.filter(
                network => network.ssid !== selectedPrimary
            );
            
            // Populate secondary dropdown excluding the selected primary network
            availableSecondaryNetworks.forEach(network => {
                const option = document.createElement('option');
                option.value = network.ssid;
                option.textContent = network.ssid;
                
                // Select the saved secondary network if it exists
                if (network.ssid === selectedSecondaryNetwork) {
                    option.selected = true;
                }
                
                secondaryDropdown.appendChild(option);
            });
            
            // Remove any existing listener before adding to prevent duplicates
            secondaryDropdown.removeEventListener('change', saveSettings);
            
            // Add change listener to the secondary dropdown
            secondaryDropdown.addEventListener('change', saveSettings);
        }
        
        // Fallback method using the options in the primary dropdown
        function updateSecondaryDropdownFromOptions() {
            const selectedPrimary = primaryDropdown.value;
            
            // Clear existing options except the first one
            secondaryDropdown.innerHTML = '<option value="" disabled selected hidden>Select Secondary WiFi</option>';
            
            // Get available networks from primary dropdown options
            const networks = Array.from(primaryDropdown.options)
                .filter(opt => opt.value && opt.value !== selectedPrimary)
                .map(opt => ({ ssid: opt.value }));
            
            // Populate secondary dropdown excluding the selected primary network
            networks.forEach(network => {
                const option = document.createElement('option');
                option.value = network.ssid;
                option.textContent = network.ssid;
                secondaryDropdown.appendChild(option);
            });
            
            // Remove any existing listener before adding to prevent duplicates
            secondaryDropdown.removeEventListener('change', saveSettings);
            
            // Add change listener to the secondary dropdown
            secondaryDropdown.addEventListener('change', saveSettings);
        }

        // Time handling functions
        function updateScheduleInfo() {
            const switchTime = switchTimeInput.value;
            const revertTime = revertTimeInput.value;
            
            if (!switchTime || !revertTime) {
                switchingDuration.textContent = "";
                return;
            }
            
            // Always enable the button
            startButton.disabled = false;
            
            // Calculate time difference
            const switchMinutes = convertTimeToMinutes(switchTime);
            let revertMinutes = convertTimeToMinutes(revertTime);
            
            // Handle cases where revert time is earlier in the day than switch time
            // by assuming it's the next day
            if (revertMinutes < switchMinutes) {
                revertMinutes += 24 * 60; // Add 24 hours worth of minutes
            }
            
            // Calculate duration from switch time to revert time
            const diffMinutes = revertMinutes - switchMinutes;
            
            // Display both start time and duration
            const formattedTime = formatTimeDisplay(switchTime);
            switchingDuration.textContent = `Starting at ${formattedTime} • Duration: ${formatTimeDiff(diffMinutes)}`;
            
            // Clear any previous border styling
            revertTimeInput.style.borderColor = "#ddd";
            switchTimeInput.style.borderColor = "#ddd";
            
            // Save settings when times change
            saveSettings();
        }
        
        function convertTimeToMinutes(timeString) {
            const [hours, minutes] = timeString.split(':').map(Number);
            return hours * 60 + minutes;
        }
        
        function formatTimeDisplay(timeString) {
            const [hours, minutes] = timeString.split(':').map(Number);
            const period = hours >= 12 ? 'PM' : 'AM';
            const displayHours = hours % 12 || 12; // Convert 0 to 12 for 12 AM
            return `${displayHours}:${minutes.toString().padStart(2, '0')} ${period}`;
        }
        
        function formatTimeDiff(minutes) {
            if (minutes < 60) {
                return `${minutes} minute${minutes !== 1 ? 's' : ''}`;
            } else {
                const hours = Math.floor(minutes / 60);
                const remainingMinutes = minutes % 60;
                if (remainingMinutes === 0) {
                    return `${hours} hour${hours !== 1 ? 's' : ''}`;
                } else {
                    return `${hours} hour${hours !== 1 ? 's' : ''} and ${remainingMinutes} minute${remainingMinutes !== 1 ? 's' : ''}`;
                }
            }
        }
        
        // Schedule management functions
        function toggleSchedule() {
            if (scheduleRunning) {
                stopSchedule();
            } else {
                startSchedule();
            }
        }
        
        // Function to start the schedule with server-side persistence
        function startSchedule() {
            // Validate inputs
            if (!primaryDropdown.value || !secondaryDropdown.value || !switchTimeInput.value || !revertTimeInput.value) {
                alert('Please select both networks and set switch and revert times.');
                return;
            }
            
            // Store schedule details
            const schedule = {
                primaryWifi: primaryDropdown.value,
                secondaryWifi: secondaryDropdown.value,
                switchTime: switchTimeInput.value,
                revertTime: revertTimeInput.value
            };
            
            // Call API to start the schedule on the server with persistence flag
            fetch('/api/start-schedule/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCsrfToken()
                },
                body: JSON.stringify({
                    ...schedule,
                    persist: true  // Add flag to persist schedule beyond user session
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Update UI to show schedule is running
                    updateScheduleUI(true, `Schedule started. Switching between ${schedule.primaryWifi} and ${schedule.secondaryWifi}`);
                    
                    // Add to activity log
                    addLogEntry(`Schedule started on server. Will switch between ${schedule.primaryWifi} and ${schedule.secondaryWifi}`, true);
                    
                    // Save state to localStorage
                    saveSettings();
                } else {
                    addLogEntry(`Failed to start schedule: ${data.error || 'Unknown error'}`, false);
                }
            })
            .catch(error => {
                addLogEntry(`Error starting schedule: ${error.message}`, false);
            });
        }
        
        function stopSchedule() {
            // Call API to stop the schedule on the server
            fetch('/api/stop-schedule/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCsrfToken()
                },
                body: JSON.stringify({})
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Update UI
                    updateScheduleUI(false);
                    
                    // Add to activity log
                    addLogEntry('Schedule stopped on server.', true);
                    
                    // Save state to localStorage
                    saveSettings();
                } else {
                    addLogEntry(`Failed to stop schedule: ${data.error || 'Unknown error'}`, false);
                }
            })
            .catch(error => {
                addLogEntry(`Error stopping schedule: ${error.message}`, false);
            });
        }

        // Enhanced function to toggle schedule status
        function toggleSchedule() {
            if (scheduleRunning) {
                stopSchedule();
            } else {
                startSchedule();
            }
        }
        
        // Check schedule status immediately and periodically
        function checkScheduleStatus() {
            fetch('/api/schedule-status/')
                .then(response => response.json())
                .then(data => {
                    if (data.active) {
                        // Update UI to show schedule is running
                        updateScheduleUI(true, data.message || 'Schedule is active and running on server');
                        
                        // Update schedule details if available
                        if (data.schedule) {
                            const serverPrimaryWifi = data.schedule.primaryWifi;
                            const serverSecondaryWifi = data.schedule.secondaryWifi;
                            
                            // Only update dropdown selections if both networks are available
                            if (serverPrimaryWifi && serverSecondaryWifi) {
                                // Check if primary network exists in dropdown
                                const primaryExists = Array.from(primaryDropdown.options)
                                    .some(opt => opt.value === serverPrimaryWifi);
                                    
                                if (primaryExists) {
                                    // Select the primary network
                                    primaryDropdown.value = serverPrimaryWifi;
                                    
                                    // Rebuild secondary dropdown to exclude the new primary
                                    updateSecondaryDropdown(serverSecondaryWifi);
                                }
                            }
                            
                            // Set the times
                            if (data.schedule.switchTime) {
                                switchTimeInput.value = data.schedule.switchTime;
                            }
                            if (data.schedule.revertTime) {
                                revertTimeInput.value = data.schedule.revertTime;
                            }
                            
                            // Update schedule info display
                            updateScheduleInfo();
                        }

                        // Add log entry if schedule is active but we just loaded the page
                        if (!document.body.hasAttribute('data-schedule-status-checked')) {
                            addLogEntry('Schedule is currently active and running on the server', true);
                            document.body.setAttribute('data-schedule-status-checked', 'true');
                        }
                    } else {
                        // Ensure UI shows schedule is not running
                        updateScheduleUI(false);
                    }
                })
                .catch(error => {
                    console.error('Error checking schedule status:', error);
                });
        }
        
        // Helper function to add a log entry to the activity log
        function addLogEntry(message, isSuccess) {
            const logTableBody = document.querySelector('.log-table tbody');
            if (!logTableBody) return;
            
            // Create a new row for the log entry
            const row = document.createElement('tr');
            
            // Get current timestamp
            const timestamp = new Date().toLocaleString();
            
            // Set the row content
            row.innerHTML = `
                <td>${timestamp}</td>
                <td>${message}</td>
                <td>
                    ${isSuccess ? 
                    '<span class="badge badge-success">Success</span>' : 
                    '<span class="badge badge-danger">Error</span>'}
                </td>
            `;
            
            // Add the new row at the top of the log table
            if (logTableBody.firstChild) {
                logTableBody.insertBefore(row, logTableBody.firstChild);
            } else {
                logTableBody.appendChild(row);
            }
            
            // Limit the number of visible log entries
            const maxEntries = 50;
            const entries = logTableBody.querySelectorAll('tr');
            if (entries.length > maxEntries) {
                for (let i = maxEntries; i < entries.length; i++) {
                    logTableBody.removeChild(entries[i]);
                }
            }
        }
        
        // Helper function to get CSRF token
        function getCsrfToken() {
            const cookieValue = document.cookie
                .split('; ')
                .find(row => row.startsWith('csrftoken='))
                ?.split('=')[1];
            return cookieValue;
        }

        // Initialize event listeners
        switchTimeInput.addEventListener('change', updateScheduleInfo);
        revertTimeInput.addEventListener('change', updateScheduleInfo);
        startButton.addEventListener('click', toggleSchedule);
        
        // Initialize the page
        populateWifiDropdowns().then(() => {
            // Check server-side schedule status after networks are loaded
            checkScheduleStatus();
            
            // Check status periodically to keep UI in sync with server
            setInterval(checkScheduleStatus, 30000); // Check every 30 seconds
        });
        updateScheduleInfo();
    });
</script>

{% endblock %}