{% extends 'base.html' %}
{% load static %}

{% block title %}Laundry Data{% endblock %}

{% block content %}
<div class="container">
    <div class="row mb-2">
        <div class="col-md-6 fw-bold text-black-50">
            <h5>SETTINGS</h5>
        </div>
        <div class="col-md-6 text-end">
            <nav aria-label="breadcrumb" class="d-inline-block">
                <ol class="breadcrumb">
                    <li class="breadcrumb-item"><a href="{% url 'home' %}">Home</a></li>
                    <li class="breadcrumb-item active" aria-current="page">Settings</li>
                </ol>
            </nav>
        </div>
    </div>
    <h1>WiFi Schedule Configuration</h1>
    
    <div class="panel">
        <div class="panel-header">Schedule Configuration</div>
        <div class="panel-bodyv2">
            <!-- Primary WiFi -->
            <div class="form-group primary-wifi-container">
                <label for="primary-wifi">Primary WiFi:</label>
                <select id="primary-wifi" class="form-control">
                    <option value="" disabled selected hidden>Select Primary WiFi</option>
                    <!-- Options will be populated dynamically -->
                </select>
            </div>
            
            <!-- Secondary WiFi -->
            <div class="form-group secondary-wifi-container">
                <label for="secondary-wifi">Secondary WiFi:</label>
                <select id="secondary-wifi" class="form-control">
                    <option value="" disabled selected hidden>Select Secondary WiFi</option>
                    <!-- Options will be populated dynamically -->
                </select>
            </div>
            
            <!-- Switch Time -->
            <div class="form-group switch-time-container">
                <label for="switch-time">Switch Time:</label>
                <input type="time" id="switch-time" class="form-control time-input" value="13:00">
                <small id="switch-time-help" class="form-text text-muted"></small>
            </div>
            
            <!-- Revert Time -->
            <div class="form-group revert-time-container">
                <label for="revert-time">Revert Time:</label>
                <input type="time" id="revert-time" class="form-control time-input" value="13:02">
                <small id="revert-time-help" class="form-text text-muted"></small>
            </div>
            
            <!-- Start Button and Switching Duration -->
            <div class="schedule-controls">
                <button class="btn start-btn" id="start-schedule-btn">Start Schedule</button>
                <div id="switching-duration" class="switching-duration"></div>
            </div>
            
            <!-- Schedule Status Indicator -->
            <div class="schedule-status" id="schedule-status">
                <span class="status-indicator"></span>
                <span class="status-text">Schedule is currently inactive</span>
            </div>
        </div>
    </div>
    
    <div class="panel">
        <div class="panel-header">Connection Status</div>
        <div class="panel-body">
            <div class="status">
                <strong>Connected to:</strong> 
                {% if current_ssid %}{{ current_ssid }}{% else %}Not connected{% endif %}
            </div>
        </div>
    </div>
    
    <div class="panel">
        <div class="panel-header">Activity Log</div>
        <div class="panel-bodyv2">
            <div class="log">
                <table class="log-table">
                    <thead>
                        <tr>
                            <th>Timestamp</th>
                            <th>Message</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody>
                        {% for log in logs %}
                        <tr>
                            <td>{{ log.timestamp }}</td>
                            <td>{{ log.message }}</td>
                            <td>
                                {% if log.is_success %}
                                    <span class="badge badge-success">Success</span>
                                {% else %}
                                    <span class="badge badge-danger">Error</span>
                                {% endif %}
                            </td>
                        </tr>
                        {% empty %}
                        <tr>
                            <td colspan="3" style="text-align: center;">System initialized... Ready for configuration.</td>
                        </tr>
                        {% endfor %}
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <div class="panel d-none">
        <div class="panel-header">Debugging Tools</div>
        <div class="panel-body">
            <button id="debug-wifi-btn" class="btn btn-sm btn-secondary" style="width: auto;">Debug WiFi Detection</button>
            <div id="debug-result" class="mt-2" style="font-family: monospace; font-size: 12px; white-space: pre-wrap; display: none;"></div>
        </div>
    </div>
</div>

<style>
    /* Panel styling remains the same */
    .panel {
        margin-bottom: 20px;
        border: 1px solid #ddd;
        border-radius: 5px;
        overflow: hidden;
    }
    .panel-header {
        background-color: #f8f9fa;
        padding: 12px 15px;
        border-bottom: 1px solid #ddd;
        font-weight: 600;
    }
    .panel-body {
        padding: 15px;
        position: relative; /* Added for absolute positioning context */
        height: 75px; /* Set a fixed height for the panel body */
    }

    .panel-bodyv2 {
        padding: 15px;
        position: relative; /* Added for absolute positioning context */
        height: 230px; /* Set a fixed height for the panel body */
    }
    
    /* Manual positioning for form elements */
    .primary-wifi-container {
        position: absolute;
        top: 20px;
        left: 40px;
        width: 420px;
    }
    
    .secondary-wifi-container {
        position: absolute;
        top: 70px;
        left: 40px;
        width: 420px;
    }
    
    .switch-time-container {
        position: absolute;
        top: 20px;
        left: 500px;
        width: 250px;
    }
    
    .revert-time-container {
        position: absolute;
        top: 70px;
        left: 500px;
        width: 250px;
    }
    
    .start-btn {
        position: absolute;
        left: 40px;
        top: 130px;
        width: 300px;
        height: 50px;
        cursor: pointer; /* Ensure cursor shows as pointer */
        z-index: 100; /* Ensure button is above other elements */
        opacity: 1 !important; /* Ensure button is visible */
        pointer-events: auto !important; /* Ensure button receives click events */
    }
    
    .switching-duration {
        position: absolute;
        top: 130px;
        left: 430px;
        min-width: 200px;
        height: 50px;
        display: flex;
        align-items: center;
        font-size: 14px;
        color: #28a745;
        font-weight: 500;
    }
    
    .form-group {
        display: flex;
        margin-bottom: 15px;
        align-items: center;
    }
    
    .form-group label {
        width: 150px;
        font-weight: 500;
        margin-right: 10px;
    }
    
    .form-control {
        padding: 8px 12px;
        border: 1px solid #ddd;
        border-radius: 4px;
        width: 100%;
    }
    
    .time-input {
        width: 120px;
    }
    
    .btn {
        padding: 2px 2px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-weight: 400;
        width: 350px;
    }
    
    .btn:hover {
        background-color: #0069d9;
    }
    
    /* Updated styles for status and log */
    .status {
        padding: 10px;
        background-color: #f8f9fa;
        border-radius: 4px;
        font-family: monospace;
    }
    
    .log {
        height: 200px;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 10px;
        font-family: monospace;
        background-color: #f8f9fa;
        overflow-y: auto;
    }

    /* Enhanced styles for the activity log table */
    .log-table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        box-shadow: 0 2px 3px rgba(0, 0, 0, 0.1);
        border-radius: 5px;
        overflow: hidden;
    }
    
    .log-table th, .log-table td {
        padding: 12px 15px;
        text-align: left;
    }
    
    .log-table th {
        background-color: #3a7bd5;
        color: white;
        font-weight: 500;
        text-transform: uppercase;
        font-size: 13px;
        letter-spacing: 0.5px;
        border: none;
    }
    
    .log-table tr {
        border-bottom: 1px solid #eee;
        transition: background-color 0.3s ease;
    }
    
    .log-table tr:nth-child(even) {
        background-color: #f9f9f9;
    }
    
    .log-table tr:hover {
        background-color: #f0f7ff;
    }

    .log-table tr:last-child td {
        border-bottom: none;
    }
    
    .badge {
        padding: 5px 10px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 500;
        display: inline-block;
        text-align: center;
        letter-spacing: 0.5px;
        min-width: 80px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12);
    }
    
    .badge-success {
        background-color: #00c853;
    }
    
    .badge-danger {
        background-color: #ff3d00;
    }

    .schedule-status {
        position: absolute;
        top: 180px;
        left: 40px;
        display: flex;
        align-items: center;
        font-size: 14px;
        font-weight: 500;
    }
    
    .status-indicator {
        display: inline-block;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background-color: #ccc; /* Default gray */
        margin-right: 8px;
    }
    
    .status-indicator.active {
        background-color: #28a745; /* Green when active */
        box-shadow: 0 0 8px #28a745;
        animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
        0% { opacity: 1; }
        50% { opacity: 0.6; }
        100% { opacity: 1; }
    }
    
    .active-schedule {
        background-color: #dc3545; /* Red for stop button */
    }
    
    .active-schedule:hover {
        background-color: #c82333; /* Darker red on hover */
    }
</style>



<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Declare all DOM elements once at the beginning
        const primaryDropdown = document.getElementById('primary-wifi');
        const secondaryDropdown = document.getElementById('secondary-wifi');
        const switchTimeInput = document.getElementById('switch-time');
        const revertTimeInput = document.getElementById('revert-time');
        const switchingDuration = document.getElementById('switching-duration');
        const startButton = document.getElementById('start-schedule-btn');
        const statusDiv = document.querySelector('.status');
        const scheduleStatusIndicator = document.querySelector('.status-indicator');
        const scheduleStatusText = document.querySelector('.status-text');
        
        // Schedule state variables
        let scheduleRunning = false;
        let scheduleTimer = null;
        let lastAction = null;

        // Function to update UI based on schedule state
        function updateScheduleUI(isRunning, message = null) {
            scheduleRunning = isRunning;
            
            // Update button text and style
            startButton.textContent = isRunning ? 'Stop Schedule' : 'Start Schedule';
            
            if (isRunning) {
                startButton.classList.add('active-schedule');
                scheduleStatusIndicator.classList.add('active');
                scheduleStatusText.textContent = message || 'Schedule is currently active';
                
                // Disable configuration fields
                primaryDropdown.disabled = true;
                secondaryDropdown.disabled = true;
                switchTimeInput.disabled = true;
                revertTimeInput.disabled = true;
                
            } else {
                startButton.classList.remove('active-schedule');
                scheduleStatusIndicator.classList.remove('active');
                scheduleStatusText.textContent = 'Schedule is currently inactive';
                
                // Enable configuration fields
                primaryDropdown.disabled = false;
                secondaryDropdown.disabled = false;
                switchTimeInput.disabled = false;
                revertTimeInput.disabled = false;
            }
            
            // Save to localStorage for UI state persistence
            localStorage.setItem('laundry_app_schedule_running', isRunning.toString());
        }

        // Load saved settings from localStorage
        function loadSavedSettings() {
            // Load switch time
            const savedSwitchTime = localStorage.getItem('laundry_app_switch_time');
            if (savedSwitchTime) {
                switchTimeInput.value = savedSwitchTime;
            }
            
            // Load revert time
            const savedRevertTime = localStorage.getItem('laundry_app_revert_time');
            if (savedRevertTime) {
                revertTimeInput.value = savedRevertTime;
            }
            
            // Load schedule running status
            const savedScheduleRunning = localStorage.getItem('laundry_app_schedule_running') === 'true';
            scheduleRunning = savedScheduleRunning;
            
            // When networks are loaded, we'll restore primary and secondary selections
            const savedPrimaryNetwork = localStorage.getItem('laundry_app_primary_network');
            const savedSecondaryNetwork = localStorage.getItem('laundry_app_secondary_network');
            
            // Return saved network selections for use when networks are loaded
            return {
                primaryNetwork: savedPrimaryNetwork,
                secondaryNetwork: savedSecondaryNetwork
            };
        }
        
        // Save settings to localStorage whenever they change
        function saveSettings() {
            // Save times
            localStorage.setItem('laundry_app_switch_time', switchTimeInput.value);
            localStorage.setItem('laundry_app_revert_time', revertTimeInput.value);
            
            // Save networks
            if (primaryDropdown.value) {
                localStorage.setItem('laundry_app_primary_network', primaryDropdown.value);
            }
            if (secondaryDropdown.value) {
                localStorage.setItem('laundry_app_secondary_network', secondaryDropdown.value);
            }
            
            // Save schedule state
            localStorage.setItem('laundry_app_schedule_running', scheduleRunning.toString());
        }

        // Function to fetch available saved networks from the computer
        async function fetchSavedNetworks() {
            try {
                console.log("Starting network fetch process...");
                
                // Loading state in status div
                if (statusDiv) {
                    statusDiv.innerHTML = '<strong>Connection Status:</strong> <span style="color: #007bff;">Fetching network information...</span>';
                }
                
                // Fetch networks from our API endpoint
                console.log("Sending request to /api/available-saved-networks/");
                const response = await fetch('/api/available-saved-networks/');
                console.log("Response received:", response.status, response.statusText);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                
                const data = await response.json();
                console.log("Network API response:", data);
                
                // Check for debug info - but no fallback creation
                if (data.debug_info) {
                    console.log("Debug info received:", data.debug_info);
                }
                
                // Make sure we have an array of networks
                let networks = Array.isArray(data) ? data : [];
                
                // Handle case where API returns object with networks array
                if (data.networks) {
                    console.log("Found networks array in response", data.networks);
                    networks = data.networks;
                }
                
                console.log(`Processed ${networks.length} networks from API response`);
                
                // Update the connection status in the UI
                updateConnectionStatus(networks);
                
                return networks;
            } catch (error) {
                console.error('Error fetching saved networks:', error);
                
                // Display error in status
                if (statusDiv) {
                    statusDiv.innerHTML = `<strong>Connection Status:</strong> <span style="color: #ff3d00;">Error: ${error.message}</span>`;
                }
                
                // Return empty array when there's an error
                return [];
            }
        }
        
        // Update connection status in the UI
        function updateConnectionStatus(networks) {
            if (!statusDiv) return;
            
            console.log("Updating connection status with networks:", networks);
            const connectedNetwork = networks.find(network => network.isConnected);
            
            if (connectedNetwork) {
                console.log("Found connected network:", connectedNetwork.ssid);
                statusDiv.innerHTML = `<strong>Connected to:</strong> ${connectedNetwork.ssid}`;
            } else if (networks.length > 0) {
                console.log("No connected network found among available networks");
                statusDiv.innerHTML = '<strong>Connected to:</strong> Not connected to any known network';
            } else {
                console.log("No networks detected");
                statusDiv.innerHTML = '<strong>Connection Status:</strong> No WiFi networks detected';
            }
        }

        // Function to populate dropdowns
        async function populateWifiDropdowns() {
            console.log("Starting WiFi dropdown population...");
            
            // Show loading indicator
            primaryDropdown.innerHTML = '<option value="" disabled selected>Loading networks...</option>';
            secondaryDropdown.innerHTML = '<option value="" disabled selected>Loading networks...</option>';
            
            // Load saved settings
            const savedSettings = loadSavedSettings();
            console.log("Loaded saved settings:", savedSettings);
            
            // Fetch networks from the API
            console.log("Fetching networks from API...");
            const networks = await fetchSavedNetworks();
            console.log(`Fetched ${networks.length} networks from API`);
            
            // Clear loading message and set appropriate options
            if (!networks || networks.length === 0) {
                console.log("No networks available to populate dropdowns");
                primaryDropdown.innerHTML = '<option value="" disabled selected>No available networks</option>';
                secondaryDropdown.innerHTML = '<option value="" disabled selected>No available networks</option>';
                return;
            }
            
            // If we have networks, set the appropriate headers
            primaryDropdown.innerHTML = '<option value="" disabled hidden>Select Primary WiFi</option>';
            secondaryDropdown.innerHTML = '<option value="" disabled hidden>Select Secondary WiFi</option>';
            
            // Get currently connected network if any
            const currentNetwork = networks.find(network => network.isConnected);
            
            // Determine which network to select in primary dropdown
            // Priority: 1) Currently connected network, 2) Previously saved selection
            let primaryToSelect = null;
            if (currentNetwork) {
                primaryToSelect = currentNetwork.ssid;
            } else if (savedSettings.primaryNetwork) {
                // Only use saved setting if the network is still available
                const savedNetworkExists = networks.some(n => n.ssid === savedSettings.primaryNetwork);
                if (savedNetworkExists) {
                    primaryToSelect = savedSettings.primaryNetwork;
                }
            }
            
            // Populate primary dropdown
            networks.forEach(network => {
                const option = document.createElement('option');
                option.value = network.ssid;
                option.textContent = network.ssid;
                
                // Select if this matches our target network
                if (network.ssid === primaryToSelect) {
                    option.selected = true;
                }
                
                primaryDropdown.appendChild(option);
            });
            
            // Store networks list for later use
            primaryDropdown.dataset.networksList = JSON.stringify(networks);
            
            // Update secondary dropdown based on primary selection
            updateSecondaryDropdownFromNetworks(networks, savedSettings.secondaryNetwork);
            
            // Remove any existing event listener first to prevent duplicates
            primaryDropdown.removeEventListener('change', handlePrimaryChange);
            
            // Add event listener to update secondary dropdown when primary selection changes
            primaryDropdown.addEventListener('change', handlePrimaryChange);
            
            // Update the schedule info display
            updateScheduleInfo();
        }
        
        // Updated function that uses the original networks list
        function updateSecondaryDropdownFromNetworks(networksList, selectedSecondaryNetwork = null) {
            const selectedPrimary = primaryDropdown.value;
            
            // Clear existing options
            secondaryDropdown.innerHTML = '<option value="" disabled selected hidden>Select Secondary WiFi</option>';
            
            if (!selectedPrimary) {
                return; // Exit if no primary network is selected
            }
            
            // Filter networks to exclude the selected primary
            const availableSecondaryNetworks = networksList.filter(
                network => network.ssid !== selectedPrimary
            );
            
            // Handle case where no secondary networks are available
            if (availableSecondaryNetworks.length === 0) {
                secondaryDropdown.innerHTML = '<option value="" disabled selected>No other networks available</option>';
                return;
            }
            
            // Populate secondary dropdown
            availableSecondaryNetworks.forEach(network => {
                const option = document.createElement('option');
                option.value = network.ssid;
                option.textContent = network.ssid;
                
                // Select the saved secondary network if it exists and is different from primary
                if (network.ssid === selectedSecondaryNetwork && selectedSecondaryNetwork !== selectedPrimary) {
                    option.selected = true;
                }
                
                secondaryDropdown.appendChild(option);
            });
            
            // Remove any existing listener before adding to prevent duplicates
            secondaryDropdown.removeEventListener('change', saveSettings);
            
            // Add change listener to the secondary dropdown
            secondaryDropdown.addEventListener('change', saveSettings);
        }

        // Time handling functions
        function updateScheduleInfo() {
            const switchTime = switchTimeInput.value;
            const revertTime = revertTimeInput.value;
            
            if (!switchTime || !revertTime) {
                switchingDuration.textContent = "";
                return;
            }
            
            // Always enable the button
            startButton.disabled = false;
            
            // Calculate time difference
            const switchMinutes = convertTimeToMinutes(switchTime);
            let revertMinutes = convertTimeToMinutes(revertTime);
            
            // Handle cases where revert time is earlier in the day than switch time
            // by assuming it's the next day
            if (revertMinutes < switchMinutes) {
                revertMinutes += 24 * 60; // Add 24 hours worth of minutes
            }
            
            // Calculate duration from switch time to revert time
            const diffMinutes = revertMinutes - switchMinutes;
            
            // Display both start time and duration
            const formattedTime = formatTimeDisplay(switchTime);
            switchingDuration.textContent = `Starting at ${formattedTime} â€¢ Duration: ${formatTimeDiff(diffMinutes)}`;
            
            // Clear any previous border styling
            revertTimeInput.style.borderColor = "#ddd";
            switchTimeInput.style.borderColor = "#ddd";
            
            // Save settings when times change
            saveSettings();
        }
        
        function convertTimeToMinutes(timeString) {
            const [hours, minutes] = timeString.split(':').map(Number);
            return hours * 60 + minutes;
        }
        
        function formatTimeDisplay(timeString) {
            const [hours, minutes] = timeString.split(':').map(Number);
            const period = hours >= 12 ? 'PM' : 'AM';
            const displayHours = hours % 12 || 12; // Convert 0 to 12 for 12 AM
            return `${displayHours}:${minutes.toString().padStart(2, '0')} ${period}`;
        }
        
        function formatTimeDiff(minutes) {
            if (minutes < 60) {
                return `${minutes} minute${minutes !== 1 ? 's' : ''}`;
            } else {
                const hours = Math.floor(minutes / 60);
                const remainingMinutes = minutes % 60;
                if (remainingMinutes === 0) {
                    return `${hours} hour${hours !== 1 ? 's' : ''}`;
                } else {
                    return `${hours} hour${hours !== 1 ? 's' : ''} and ${remainingMinutes} minute${remainingMinutes !== 1 ? 's' : ''}`;
                }
            }
        }
        
        // Schedule management functions
        function toggleSchedule() {
            console.log("Toggle schedule clicked, current state:", scheduleRunning);
            if (scheduleRunning) {
                stopSchedule();
            } else {
                startSchedule();
            }
        }
        
        // Function to start the schedule with server-side persistence
        function startSchedule() {
            // Validate inputs
            if (!primaryDropdown.value || !secondaryDropdown.value || !switchTimeInput.value || !revertTimeInput.value) {
                alert('Please select both networks and set switch and revert times.');
                return;
            }
            
            // Store schedule details
            const schedule = {
                primaryWifi: primaryDropdown.value,
                secondaryWifi: secondaryDropdown.value,
                switchTime: switchTimeInput.value,
                revertTime: revertTimeInput.value
            };
            
            // Call API to start the schedule on the server with persistence flag
            fetch('/api/start-schedule/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCsrfToken()
                },
                body: JSON.stringify({
                    ...schedule,
                    persist: true  // Add flag to persist schedule beyond user session
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Update UI to show schedule is running
                    updateScheduleUI(true, `Schedule started. Switching between ${schedule.primaryWifi} and ${schedule.secondaryWifi}`);
                    
                    // Add to activity log
                    addLogEntry(`Schedule started on server. Will switch between ${schedule.primaryWifi} and ${schedule.secondaryWifi}`, true);
                    
                    // Save state to localStorage
                    saveSettings();
                } else {
                    addLogEntry(`Failed to start schedule: ${data.error || 'Unknown error'}`, false);
                }
            })
            .catch(error => {
                addLogEntry(`Error starting schedule: ${error.message}`, false);
            });
        }
        
        function stopSchedule() {
            // Call API to stop the schedule on the server
            fetch('/api/stop-schedule/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCsrfToken()
                },
                body: JSON.stringify({})
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Update UI
                    updateScheduleUI(false);
                    
                    // Add to activity log
                    addLogEntry('Schedule stopped on server.', true);
                    
                    // Save state to localStorage
                    saveSettings();
                } else {
                    addLogEntry(`Failed to stop schedule: ${data.error || 'Unknown error'}`, false);
                }
            })
            .catch(error => {
                addLogEntry(`Error stopping schedule: ${error.message}`, false);
            });
        }

        // Fix for button click event
        function initializeEventListeners() {
            console.log("Initializing button event listeners...");
            // Remove any existing listeners first
            startButton.removeEventListener('click', toggleSchedule);
            switchTimeInput.removeEventListener('change', updateScheduleInfo);
            revertTimeInput.removeEventListener('change', updateScheduleInfo);
            
            // Add fresh event listeners
            switchTimeInput.addEventListener('change', updateScheduleInfo);
            revertTimeInput.addEventListener('change', updateScheduleInfo);
            startButton.addEventListener('click', toggleSchedule);
            
            // Make sure button is enabled
            startButton.disabled = false;
            startButton.style.pointerEvents = 'auto';
            startButton.style.opacity = '1';
            console.log("Button event listener attached:", startButton);
        }
        
        // Check schedule status immediately and periodically
        function checkScheduleStatus() {
            fetch('/api/schedule-status/')
                .then(response => response.json())
                .then(data => {
                    if (data.active) {
                        // Update UI to show schedule is running
                        updateScheduleUI(true, data.message || 'Schedule is active and running on server');
                        
                        // Update schedule details if available
                        if (data.schedule) {
                            const serverPrimaryWifi = data.schedule.primaryWifi;
                            const serverSecondaryWifi = data.schedule.secondaryWifi;
                            
                            // Only update dropdown selections if both networks are available
                            if (serverPrimaryWifi && serverSecondaryWifi) {
                                // Check if primary network exists in dropdown
                                const primaryExists = Array.from(primaryDropdown.options)
                                    .some(opt => opt.value === serverPrimaryWifi);
                                    
                                if (primaryExists) {
                                    // Select the primary network
                                    primaryDropdown.value = serverPrimaryWifi;
                                    
                                    // Rebuild secondary dropdown to exclude the new primary
                                    updateSecondaryDropdown(serverSecondaryWifi);
                                }
                            }
                            
                            // Set the times
                            if (data.schedule.switchTime) {
                                switchTimeInput.value = data.schedule.switchTime;
                            }
                            if (data.schedule.revertTime) {
                                revertTimeInput.value = data.schedule.revertTime;
                            }
                            
                            // Update schedule info display
                            updateScheduleInfo();
                        }

                        // Add log entry if schedule is active but we just loaded the page
                        if (!document.body.hasAttribute('data-schedule-status-checked')) {
                            addLogEntry('Schedule is currently active and running on the server', true);
                            document.body.setAttribute('data-schedule-status-checked', 'true');
                        }
                    } else {
                        // Ensure UI shows schedule is not running
                        updateScheduleUI(false);
                    }
                    
                    // Also refresh logs whenever we check status
                    refreshLogs();
                })
                .catch(error => {
                    console.error('Error checking schedule status:', error);
                });
        }
        
        // Helper function to add a log entry to the activity log
        function addLogEntry(message, isSuccess) {
            const logTableBody = document.querySelector('.log-table tbody');
            if (!logTableBody) return;
            
            // Create a new row for the log entry
            const row = document.createElement('tr');
            
            // Get current timestamp
            const timestamp = new Date().toLocaleString();
            
            // Set the row content
            row.innerHTML = `
                <td>${timestamp}</td>
                <td>${message}</td>
                <td>
                    ${isSuccess ? 
                    '<span class="badge badge-success">Success</span>' : 
                    '<span class="badge badge-danger">Error</span>'}
                </td>
            `;
            
            // Add the new row at the top of the log table
            if (logTableBody.firstChild) {
                logTableBody.insertBefore(row, logTableBody.firstChild);
            } else {
                logTableBody.appendChild(row);
            }
            
            // Limit the number of visible log entries
            const maxEntries = 50;
            const entries = logTableBody.querySelectorAll('tr');
            if (entries.length > maxEntries) {
                for (let i = maxEntries; i < entries.length; i++) {
                    logTableBody.removeChild(entries[i]);
                }
            }
        }
        
        // Helper function to get CSRF token
        function getCsrfToken() {
            const cookieValue = document.cookie
                .split('; ')
                .find(row => row.startsWith('csrftoken='))
                ?.split('=')[1];
            return cookieValue;
        }

        // Fix for missing handlePrimaryChange function
        function handlePrimaryChange() {
            // Get the networks list from the dataset
            const networks = JSON.parse(primaryDropdown.dataset.networksList || '[]');
            
            // Get the currently selected primary network
            const selectedPrimary = primaryDropdown.value;
            
            // Update secondary dropdown based on the current selection
            updateSecondaryDropdownFromNetworks(networks, null);
            
            // Save the updated settings
            saveSettings();
            
            console.log(`Primary network changed to: ${selectedPrimary}`);
        }
        
        // Updated function that uses the original networks list
        function updateSecondaryDropdownFromNetworks(networksList, selectedSecondaryNetwork = null) {
            const selectedPrimary = primaryDropdown.value;
            
            // Clear existing options
            secondaryDropdown.innerHTML = '<option value="" disabled selected hidden>Select Secondary WiFi</option>';
            
            if (!selectedPrimary) {
                return; // Exit if no primary network is selected
            }
            
            // Filter networks to exclude the selected primary
            const availableSecondaryNetworks = networksList.filter(
                network => network.ssid !== selectedPrimary
            );
            
            // Handle case where no secondary networks are available
            if (availableSecondaryNetworks.length === 0) {
                secondaryDropdown.innerHTML = '<option value="" disabled selected>No other networks available</option>';
                return;
            }
            
            // Populate secondary dropdown
            availableSecondaryNetworks.forEach(network => {
                const option = document.createElement('option');
                option.value = network.ssid;
                option.textContent = network.ssid;
                
                // Select the saved secondary network if it exists and is different from primary
                if (network.ssid === selectedSecondaryNetwork && selectedSecondaryNetwork !== selectedPrimary) {
                    option.selected = true;
                }
                
                secondaryDropdown.appendChild(option);
            });
            
            // Remove any existing listener before adding to prevent duplicates
            secondaryDropdown.removeEventListener('change', saveSettings);
            
            // Add change listener to the secondary dropdown
            secondaryDropdown.addEventListener('change', saveSettings);
        }

        // Initialize the page
        populateWifiDropdowns().then(() => {
            // Initialize event listeners after dropdowns are populated
            initializeEventListeners();
            
            // Check server-side schedule status after networks are loaded
            checkScheduleStatus();
            
            // Check status periodically to keep UI in sync with server
            setInterval(checkScheduleStatus, 30000); // Check every 30 seconds
        });
        
        updateScheduleInfo();
        initializeEventListeners(); // Initialize event listeners immediately as well
        
        // Schedule periodic log refreshes
        setInterval(refreshLogs, 10000); // Refresh logs every 10 seconds
    });

    // Add debugging helper
    document.getElementById('debug-wifi-btn')?.addEventListener('click', async function() {
        const debugResult = document.getElementById('debug-result');
        debugResult.style.display = 'block';
        debugResult.textContent = 'Checking WiFi detection methods...';
        
        try {
            const response = await fetch('/api/debug-wifi/');
            const data = await response.json();
            debugResult.textContent = JSON.stringify(data, null, 2);
            console.log('WiFi Debug Info:', data);
        } catch(err) {
            debugResult.textContent = `Error: ${err.message}`;
        }
    });
    
    // Enhance the log refresh functionality to show the latest logs
    function refreshLogs() {
        fetch('/api/connection-logs/')
            .then(response => response.json())
            .then(logs => {
                const logTableBody = document.querySelector('.log-table tbody');
                if (!logTableBody) return;
                
                // Clear existing logs
                logTableBody.innerHTML = '';
                
                // Add new logs
                logs.forEach(log => {
                    const row = document.createElement('tr');
                    
                    // Format timestamp
                    const timestamp = new Date(log.timestamp).toLocaleString();
                    
                    // Set the row content
                    row.innerHTML = `
                        <td>${timestamp}</td>
                        <td>${log.message}</td>
                        <td>
                            ${log.is_success ? 
                            '<span class="badge badge-success">Success</span>' : 
                            '<span class="badge badge-danger">Error</span>'}
                        </td>
                    `;
                    
                    // Add the new row to the table
                    logTableBody.appendChild(row);
                });
            })
            .catch(error => {
                console.error('Error fetching logs:', error);
            });
    }
</script>

{% endblock %}